/// Generating constants for poseidon hashing function
/// All memory allocation is on arena allocator
///
const std = @import("std");
const Felt252 = @import("./math/fields/starknet.zig").Felt252;
const Allocator = std.mem.Allocator;

const round_constants_block = "/// based on https://github.com/starkware-industries/poseidon/blob/5403dff9ff4eadb07deb5c0a43e88bedb011deb8/poseidon3.txt\n" ++
    "///\n///\n/// This file is autogenerated by poseidon_consts_gen.zig\n///\n///\n" ++
    "const Felt252 = @import(\"../../../fields/starknet.zig\").Felt252;\n\npub const POSEIDON_COMPRESSED_ROUND_CONSTS: [{d}]Felt252 = .{{\n {s}\n }};" ++
    "\n\npub const POSEIDON_FULL_ROUNDS: usize = {d};\n\npub const POSEIDON_PARTIAL_ROUNDS: usize = {d};\n\n";

const round_constants_block_item = ".{{ .fe = [4]u64{{ {}, {}, {}, {}, }} }},\n";

const ConfigJSON = struct {
    full_rounds: usize,
    partial_rounds: usize,
    round_keys: [][3]u256,
};

// generate_round_constant_block - injecting compressed round constants and config into template
// result slice owner is caller, so it should be deinit by caller
fn generate_round_constant_block(allocator: Allocator, config: ConfigJSON, round_keys: []Felt252) ![]const u8 {
    var array_tpl = std.ArrayList(u8).init(allocator);
    defer array_tpl.deinit();

    for (round_keys) |round_key| {
        const value = round_key.fe;
        // writing array felt item
        try std.fmt.format(array_tpl.writer(), round_constants_block_item, .{ value[0], value[1], value[2], value[3] });
    }

    var result = std.ArrayList(u8).init(allocator);

    try std.fmt.format(result.writer(), round_constants_block, .{ round_keys.len, try array_tpl.toOwnedSlice(), config.full_rounds, config.partial_rounds });

    return try result.toOwnedSlice();
}

// parse_config - parsing config from json, allocator should be arena allocator
fn parse_config(allocator: Allocator, json_spec: []const u8) !ConfigJSON {
    const config = try std.json.parseFromSliceLeaky(
        ConfigJSON,
        allocator,
        json_spec,
        .{ .allocate = std.json.AllocWhen.alloc_always },
    );

    return config;
}

// compress_round_constants - compressing round constants
// caller is owner of result slice and should deinit it
fn compress_round_constants(allocator: Allocator, config: ConfigJSON, round_constants: [][3]Felt252) ![]Felt252 {
    var result = std.ArrayList(Felt252).init(allocator);

    for (round_constants[0 .. config.full_rounds / 2]) |rk| {
        try result.append(rk[0]);
        try result.append(rk[1]);
        try result.append(rk[2]);
    }

    var idx = config.full_rounds / 2;

    var state = [_]Felt252{Felt252.zero()} ** 3;

    // Add keys for partial rounds
    for (0..config.partial_rounds) |_| {
        state[0] = Felt252.add(state[0], round_constants[idx][0]);
        state[1] = Felt252.add(state[1], round_constants[idx][1]);
        state[2] = Felt252.add(state[2], round_constants[idx][2]);
        // Add last state
        try result.append(state[2]);

        // Reset last state
        state[2] = Felt252.zero();

        const st = Felt252.add(Felt252.add(state[0], state[1]), state[2]);

        // MixLayer
        state[0] = Felt252.add(st, Felt252.mul(Felt252.two(), state[0]));
        state[1] = Felt252.sub(st, Felt252.mul(Felt252.two(), state[1]));
        state[2] = Felt252.sub(st, Felt252.mul(Felt252.two(), state[2]));

        idx += 1;
    }

    // Add keys for first of the last full rounds
    state[0] = Felt252.add(state[0], round_constants[idx][0]);
    state[1] = Felt252.add(state[1], round_constants[idx][1]);
    state[2] = Felt252.add(state[2], round_constants[idx][2]);

    try result.append(state[0]);
    try result.append(state[1]);
    try result.append(state[2]);

    for (round_constants[config.full_rounds / 2 + config.partial_rounds + 1 ..]) |rk| {
        try result.append(rk[0]);
        try result.append(rk[1]);
        try result.append(rk[2]);
    }

    return try result.toOwnedSlice();
}

// parse_numbers_to_field_element - parsing numbers to field element
// caller is owner of result slice and should deinit it
fn parse_numbers_to_field_element(allocator: Allocator, keys: [][3]u256) ![][3]Felt252 {
    var result = try allocator.alloc([3]Felt252, keys.len);

    for (keys, 0..) |key, idx| {
        for (key, 0..) |k, idy| {
            result[idx][idy] = Felt252.fromInteger(k);
        }
    }

    return result;
}

pub fn main() !void {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();
    const allocator = arena.allocator();

    // writing constants for poseidon
    const config = try parse_config(allocator, @embedFile("./math/crypto/poseidon/gen/config.json"));

    const round_consts = try parse_numbers_to_field_element(allocator, config.round_keys);

    const compressed_round_consts = try compress_round_constants(allocator, config, round_consts);

    const result = try generate_round_constant_block(allocator, config, compressed_round_consts);
    var file = try std.fs.cwd().openFile("./src/math/crypto/poseidon/gen/constants.zig", .{ .mode = .write_only });

    try file.writer().writeAll(result);
}
